% This code produces the probability of obtaining an
% acceptable error as a function of the calibration window length. As inputs, it takes
% a matrix of errors in the predicted transition time named 'ExtinctTimeError2' with rows corresponding to
% the start time of the calibration window and columns corresponding to the
% calibration window length, a vector of window lengths 
% 'WindowLengthVec', a vector of window start times 'StartTimeVec' and the true extinction time
% 'TrueExtinctTime', all generated by e.g. % CalibWindowError_quadratic_pretimeseries.m.

acceptableError = 500;
nCalibWindowStart = size(transitionTimeError, 1);
nCalibWindowLength = size(transitionTimeError, 2);


% Since the start time and the window length are dependent (they must add
% up to the transition time), we need to limit their ranges when computing
% the averages to ranges where they are independent.

% format: PredictorVariable_SpecifiedVariableMax 

windowLength_windowLengthMax = 1800;
windowLength_startTimeMax = 900;
startTime_windowLengthMax = 1500;
startTime_startTimeMax = 1200;

WL_WLMaxFinder = windowLength_windowLengthMax * ones(1, nCalibWindowLength);
WL_STMaxFinder = windowLength_startTimeMax * ones(1, nCalibWindowStart);

ST_WLMaxFinder = startTime_windowLengthMax * ones(1, nCalibWindowLength);
ST_STMaxFinder = startTime_startTimeMax * ones(1, nCalibWindowStart);

[~, WL_WLMaxIndex] = min(abs(WindowLengthVec - WL_WLMaxFinder));
[~, WL_STMaxIndex] = min(abs(StartTimeVec - WL_STMaxFinder));
[~, ST_WLMaxIndex] = min(abs(WindowLengthVec - ST_WLMaxFinder));
[~, ST_STMaxIndex] = min(abs(StartTimeVec - ST_STMaxFinder));

fractionAcceptableErrorsWindowLength = zeros(WL_WLMaxIndex, 1);
fractionAcceptableErrorsStartTime = zeros(ST_STMaxIndex, 1);

% For loops follow the convention that the variable that is fixed comes
% first, then the variable that is averaged over.
% But 'i' always denotes the Start Time (1st dimension in ExtinctTimeError2
% ) and 'j' always denotes the Window Length

for j = 1:WL_WLMaxIndex
    acceptableErrorSum = 0;
    for i = 1:WL_STMaxIndex   % elements below the secondary diagonal are invalid because they correspond to 
                                    % calibration windows which extend after the transition
        if ~isnan(transitionTimeError(i, j)) && abs(transitionTimeError(i, j)) <= acceptableError
            acceptableErrorSum = acceptableErrorSum + 1;
        end
    end
    fractionAcceptableErrorsWindowLength(j) = acceptableErrorSum / WL_STMaxIndex;
end

for i = 1:ST_STMaxIndex
    acceptableErrorSum = 0;
    for j = 1:ST_WLMaxIndex   % elements below the secondary diagonal are invalid because they correspond to 
                                    % calibration windows which extend after the transition
        if ~isnan(transitionTimeError(i, j)) && abs(transitionTimeError(i, j)) <= acceptableError
            acceptableErrorSum = acceptableErrorSum + 1;
        end
    end
    fractionAcceptableErrorsStartTime(i) = acceptableErrorSum / ST_WLMaxIndex;
end

figure(5)
subplot(1, 2, 1)
plot(WindowLengthVec(1:WL_WLMaxIndex), fractionAcceptableErrorsWindowLength', 'LineWidth', 1.5)
xlabel('Calibration window length', 'fontsize', 14);
ylabel('Proportion of predictions within tolerance', 'fontsize', 14);
title('(a)', 'FontSize', 14)
axis([0 windowLength_windowLengthMax 0 1])

subplot(1, 2, 2)
plot((StartTimeVec(1:ST_STMaxIndex)) - TrueExtinctTime, fractionAcceptableErrorsStartTime', 'LineWidth', 1.5)
xlabel('Calibration window start time', 'fontsize', 14);
title('(b)', 'FontSize', 14)
axis([-2790 -2790 + startTime_startTimeMax 0 1])